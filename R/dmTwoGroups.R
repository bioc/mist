#' Differential methylation evaluation over time for scDNA-seq data under the 2-group scenario.
#'
#' This function performs DM analysis to identify genomic features showing drastic
#' changes between two groups along pseudotime, by modeling the methylation changes
#' and comparing the fitted curves for each group.
#'
#' @param Dat_sce The updated sce object with 2 numeric matrices in the rowData:
#' - `mist_pars_group1`: A numeric matrix of estimated parameters for all genomic features in group 1 (generated by \code{estiParamTwoGroups}).
#' - `mist_pars_group2`: A numeric matrix of estimated parameters for all genomic features in group 2.
#'
#' @return The updated sce object with a named numeric vector where each value corresponds to a genomic feature
#' (e.g., a gene). The values represent the integral of the differences between the
#' fitted curves of scDNA methylation levels for the two groups. The values are sorted
#' in descending order, with larger values indicating more drastic differences between the groups.
#'
#' @import MCMCpack BiocParallel car mvtnorm
#' @importFrom S4Vectors subjectHits queryHits Rle
#' @importFrom methods is
#' @importFrom rtracklayer start offset end
#' @importFrom Matrix cov2cor toeplitz update
#' @importFrom stats pgamma poly qgamma rnorm runif
#' @export
#'
#' @examples
#' library(mist)
#' data <- readRDS(system.file("extdata", "small_sampleData_sce.rds", package = "mist"))
#' Dat_sce_new <- estiParamTwo(
#'     Dat_sce = data,
#'     Dat_name_g1 = "Methy_level_group1",
#'     Dat_name_g2 = "Methy_level_group2",
#'     ptime_name_g1 = "pseudotime",
#'     ptime_name_g2 = "pseudotime_g2"
#' )
#' dm_sce_two <- dmTwoGroups(Dat_sce_new)
dmTwoGroups <- function(Dat_sce) {
  # Check if Dat_sce is a SingleCellExperiment object
  if (!methods::is(Dat_sce, "SingleCellExperiment")) {
    stop("Dat_sce must be a SingleCellExperiment object.",
         call. = TRUE, domain = NULL)
  }
  
  # Extract parameter matrices
  mist_pars_matrix1 <- rowData(Dat_sce)$mist_pars_group1
  mist_pars_matrix2 <- rowData(Dat_sce)$mist_pars_group2
  
  # Split into lists once, and avoid repeated conversions
  beta_sigma_list_group <- list(
    Group1 = split(as.data.frame(mist_pars_matrix1), rownames(mist_pars_matrix1)),
    Group2 = split(as.data.frame(mist_pars_matrix2), rownames(mist_pars_matrix2))
  )
  
  # Find and keep only common features
  common_names <- intersect(names(beta_sigma_list_group$Group1), 
                            names(beta_sigma_list_group$Group2))
  beta_sigma_list_group <- lapply(beta_sigma_list_group, `[`, common_names)
  
  # Simplify feature validation using vectorized operations
  valid_features <- sapply(common_names, function(name) {
    all(is.finite(as.numeric(beta_sigma_list_group$Group1[[name]]))) && 
      all(is.finite(as.numeric(beta_sigma_list_group$Group2[[name]])))
  })
  
  # Subset valid features only
  beta_mu_mean_group1 <- beta_sigma_list_group$Group1[valid_features]
  beta_mu_mean_group2 <- beta_sigma_list_group$Group2[valid_features]
  
  # Efficient parallel computation of integrals
  int_list <- bplapply(seq_along(beta_mu_mean_group1), function(i) {
    calculate_integral(
      as.numeric(beta_mu_mean_group1[[i]]), 
      as.numeric(beta_mu_mean_group2[[i]])
    )
  }, BPPARAM = SnowParam())
  
  # Name the results and sort
  names(int_list) <- names(beta_mu_mean_group1)
  int_res <- sort(unlist(int_list), decreasing = TRUE)
  
  # Assign results to rowData and return
  rowData(Dat_sce)$mist_int_2group <- int_res
  return(Dat_sce)
}
